[/
 / Copyright (c) 2003-2009 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[section:reference Reference]



[section:core Core Classes]

  
[section:istream istream]


The class `istream` supports reading content from a specified URL. 


  class istream :
    public std::basic_istream< char >


['[*Member Functions]]
[table
  [[Name][Description]]

  [
    [[link urdl.reference.core.istream.close [*close]]]
    [Closes the stream. ]
  ]
  
  [
    [[link urdl.reference.core.istream.content_length [*content_length]]]
    [Gets the length of the content obtained from the URL. ]
  ]
  
  [
    [[link urdl.reference.core.istream.content_type [*content_type]]]
    [Gets the MIME type of the content obtained from the URL. ]
  ]
  
  [
    [[link urdl.reference.core.istream.error [*error]]]
    [Gets the last error associated with the stream. ]
  ]
  
  [
    [[link urdl.reference.core.istream.get_option [*get_option]]]
    [Gets the current value of an option that controls the behaviour of the stream. ]
  ]
  
  [
    [[link urdl.reference.core.istream.get_options [*get_options]]]
    [Gets the values of all options set on the stream. ]
  ]
  
  [
    [[link urdl.reference.core.istream.headers [*headers]]]
    [Gets the protocol-specific headers obtained from the URL. ]
  ]
  
  [
    [[link urdl.reference.core.istream.is_open [*is_open]]]
    [Determines whether the stream is open. ]
  ]
  
  [
    [[link urdl.reference.core.istream.istream [*istream]]]
    [Constructs an object of class istream. ]
  ]
  
  [
    [[link urdl.reference.core.istream.open [*open]]]
    [Opens the specified URL. ]
  ]
  
  [
    [[link urdl.reference.core.istream.rdbuf [*rdbuf]]]
    [Gets the underlying stream buffer. ]
  ]
  
  [
    [[link urdl.reference.core.istream.read_timeout [*read_timeout]]]
    [Gets the read timeout of the stream. 

     Sets the read timeout of the stream. ]
  ]
  
  [
    [[link urdl.reference.core.istream.set_option [*set_option]]]
    [Sets an option to control the behaviour of the stream. ]
  ]
  
  [
    [[link urdl.reference.core.istream.set_options [*set_options]]]
    [Sets options to control the behaviour of the stream. ]
  ]
  
]


['[*Remarks]]
  
The class stores an object of class `istreambuf`.

Currently supported URL protocols are `http`, `https` and `file`.


['[*Example]]
  
To read the entire content of a resource located by a URL into a string: 

   urdl::istream is("http://www.boost.org/LICENSE_1_0.txt");
   if (is)
   {
     std::string content;
     if (std::getline(is, content, std::char_traits<char>::eof()))
     {
       ...
     }
   }




['[*Requirements]]
  
[*Header:] `<urdl/istream.hpp>`

[*Namespace:] `urdl`



[section:close istream::close]

[indexterm2 close..istream] 
Closes the stream. 


  void close();



['[*Remarks]]
  
Calls `rdbuf()->close()` and, if that function returns a null pointer, calls `setstate(failbit)` (which may throw `ios_base::failure`). 



[endsect]



[section:content_length istream::content_length]

[indexterm2 content_length..istream] 
Gets the length of the content obtained from the URL. 


  std::size_t content_length() const;



['[*Return Value]]
      
The length, in bytes, of the content. If the content associated with the URL does not specify a length, `std::numeric_limits<std::size_t>::max()`.

['[*Remarks]]
  
Returns `rdbuf()->content_length()`. 



[endsect]



[section:content_type istream::content_type]

[indexterm2 content_type..istream] 
Gets the MIME type of the content obtained from the URL. 


  std::string content_type() const;



['[*Return Value]]
      
A string specifying the MIME type. Examples of possible return values include `text/plain`, `text/html` and `image/png`.

['[*Remarks]]
  
Returns `rdbuf()->content_type()`.

Not all URL protocols support a content type. For these protocols, this function returns an empty string. 


[endsect]



[section:error istream::error]

[indexterm2 error..istream] 
Gets the last error associated with the stream. 


  const boost::system::error_code & error() const;



['[*Return Value]]
      
An `error_code` corresponding to the last error from the stream.

['[*Remarks]]
  
Returns a reference to an `error_code` object representing the last failure reported by an `istreambuf` function. The set of possible `error_code` values and categories depends on the protocol of the URL used to open the stream.

['[*Example]]
  
To take action given a specific error: 

   urdl::istream is("http://somesite/page");
   if (!is)
   {
     if (is.error() == urdl::http::errc::forbidden)
     {
       std::cout << "Computer says no" << std::endl;
     }
   }






[endsect]



[section:get_option istream::get_option]

[indexterm2 get_option..istream] 
Gets the current value of an option that controls the behaviour of the stream. 


  template<
      typename Option>
  Option get_option() const;



['[*Return Value]]
      
The current value of the option.

['[*Remarks]]
  
Returns `rdbuf()->get_option<Option>()`. Options are uniquely identified by type.

['[*Example]]
  


   urdl::istream is(io_service);
   urdl::http::max_redirects option
     = is.get_option<urdl::http::max_redirects>();
   std::size_t value = option.value();






[endsect]



[section:get_options istream::get_options]

[indexterm2 get_options..istream] 
Gets the values of all options set on the stream. 


  option_set get_options() const;



['[*Return Value]]
      
An option set containing all options from the stream.

['[*Remarks]]
  
Returns `rdbuf()->get_options()`.

['[*Example]]
  
To get the options that have been set on the stream: 

   urdl::istream is;
   ...
   urdl::option_set options(is.get_options());
   urdl::http::max_redirects option
     = options.get_option<urdl::http::max_redirects>();
   std::size_t value = option.value();






[endsect]



[section:headers istream::headers]

[indexterm2 headers..istream] 
Gets the protocol-specific headers obtained from the URL. 


  std::string headers() const;



['[*Return Value]]
      
A string containing the headers returned with the content from the URL. The format and interpretation of these headers is specific to the protocol associated with the URL.

['[*Remarks]]
  
Returns `rdbuf()->headers()`. 



[endsect]



[section:is_open istream::is_open]

[indexterm2 is_open..istream] 
Determines whether the stream is open. 


  bool is_open() const;



['[*Return Value]]
      
`true` if the stream is open, `false` otherwise.

['[*Remarks]]
  
Returns `rdbuf()->is_open()`. 



[endsect]


[section:istream istream::istream]

[indexterm2 istream..istream] 
Constructs an object of class `istream`. 


  ``[link urdl.reference.core.istream.istream.overload1 istream]``();
  ``  [''''&raquo;''' [link urdl.reference.core.istream.istream.overload1 more...]]``

  explicit ``[link urdl.reference.core.istream.istream.overload2 istream]``(
      const url & u);
  ``  [''''&raquo;''' [link urdl.reference.core.istream.istream.overload2 more...]]``


[section:overload1 istream::istream (1 of 2 overloads)]


Constructs an object of class `istream`. 


  istream();



['[*Remarks]]
  
Initializes the base class with `std::basic_istream<char>(sb)`, where sb is an object of class `istreambuf` stored within the class. 



[endsect]



[section:overload2 istream::istream (2 of 2 overloads)]


Constructs an object of class `istream`. 


  explicit istream(
      const url & u);



['[*Parameters]]
    

[variablelist
  
[[u][The URL to open.]]

]

['[*Remarks]]
  
Initializes the base class with `std::basic_istream<char>(sb)`, where `sb` is an object of class `istreambuf` stored within the class. It also opens `sb` by performing `sb.open(u)` and, if that fails (returns a null pointer), calls `setstate(failbit)`. 



[endsect]


[endsect]


[section:open istream::open]

[indexterm2 open..istream] 
Opens the specified URL. 


  void open(
      const url & u);



['[*Parameters]]
    

[variablelist
  
[[u][The URL to open.]]

]

['[*Remarks]]
  
Calls `rdbuf()->open(u)`. If that function does not return a null pointer, calls `clear()`. Otherwise calls `setstate(failbit)` (which may throw `ios_base::failure`). 



[endsect]



[section:rdbuf istream::rdbuf]

[indexterm2 rdbuf..istream] 
Gets the underlying stream buffer. 


  istreambuf * rdbuf() const;



['[*Return Value]]
      
A pointer to the stream buffer contained within the class. 



[endsect]


[section:read_timeout istream::read_timeout]

[indexterm2 read_timeout..istream] 
Gets the read timeout of the stream. 


  std::size_t ``[link urdl.reference.core.istream.read_timeout.overload1 read_timeout]``() const;
  ``  [''''&raquo;''' [link urdl.reference.core.istream.read_timeout.overload1 more...]]``


Sets the read timeout of the stream. 


  void ``[link urdl.reference.core.istream.read_timeout.overload2 read_timeout]``(
      std::size_t milliseconds);
  ``  [''''&raquo;''' [link urdl.reference.core.istream.read_timeout.overload2 more...]]``


[section:overload1 istream::read_timeout (1 of 2 overloads)]


Gets the read timeout of the stream. 


  std::size_t read_timeout() const;



['[*Return Value]]
      
The timeout, in milliseconds, used for individual read operations on the underlying transport.

['[*Remarks]]
  
Returns `rdbuf()->read_timeout()`. 



[endsect]



[section:overload2 istream::read_timeout (2 of 2 overloads)]


Sets the read timeout of the stream. 


  void read_timeout(
      std::size_t milliseconds);



['[*Parameters]]
    

[variablelist
  
[[milliseconds][The timeout, in milliseconds, to be used for individual read operations on the underlying transport.]]

]

['[*Remarks]]
  
Performs `rdbuf()->read_timeout(milliseconds)`. 



[endsect]


[endsect]


[section:set_option istream::set_option]

[indexterm2 set_option..istream] 
Sets an option to control the behaviour of the stream. 


  template<
      typename Option>
  void set_option(
      const Option & option);



['[*Parameters]]
    

[variablelist
  
[[option][The option to be set on the stream.]]

]

['[*Remarks]]
  
Performs `rdbuf()->set_option(option)`. Options are uniquely identified by type.

['[*Example]]
  


   urdl::istream is;
   is.set_option(urdl::http::max_redirects(1));






[endsect]



[section:set_options istream::set_options]

[indexterm2 set_options..istream] 
Sets options to control the behaviour of the stream. 


  void set_options(
      const option_set & options);



['[*Parameters]]
    

[variablelist
  
[[options][The options to be set on the stream. The options in the set are added on top of any options already set on the stream.]]

]

['[*Remarks]]
  
Performs `rdbuf()->set_options(options)`.

['[*Example]]
  


   urdl::istream is(io_service);
   urdl::option_set options;
   options.set_option(urdl::http::max_redirects(1));
   options.set_option(urdl::ssl::verify_peer(false));
   stream.set_options(options);






[endsect]



[endsect]

[section:istreambuf istreambuf]


The class `istreambuf` associates the input sequence with the content from a specified URL. 


  class istreambuf :
    public std::streambuf


['[*Member Functions]]
[table
  [[Name][Description]]

  [
    [[link urdl.reference.core.istreambuf.close [*close]]]
    [Closes the stream buffer. ]
  ]
  
  [
    [[link urdl.reference.core.istreambuf.content_length [*content_length]]]
    [Gets the length of the content obtained from the URL. ]
  ]
  
  [
    [[link urdl.reference.core.istreambuf.content_type [*content_type]]]
    [Gets the MIME type of the content obtained from the URL. ]
  ]
  
  [
    [[link urdl.reference.core.istreambuf.get_option [*get_option]]]
    [Gets the current value of an option that controls the behaviour of the stream buffer. ]
  ]
  
  [
    [[link urdl.reference.core.istreambuf.get_options [*get_options]]]
    [Gets the values of all options set on the stream. ]
  ]
  
  [
    [[link urdl.reference.core.istreambuf.headers [*headers]]]
    [Gets the protocol-specific headers obtained from the URL. ]
  ]
  
  [
    [[link urdl.reference.core.istreambuf.is_open [*is_open]]]
    [Determines whether the stream buffer is open. ]
  ]
  
  [
    [[link urdl.reference.core.istreambuf.istreambuf [*istreambuf]]]
    [Constructs an object of class istreambuf. ]
  ]
  
  [
    [[link urdl.reference.core.istreambuf.open [*open]]]
    [Opens the specified URL. ]
  ]
  
  [
    [[link urdl.reference.core.istreambuf.puberror [*puberror]]]
    [Gets the last error associated with the stream buffer. ]
  ]
  
  [
    [[link urdl.reference.core.istreambuf.read_timeout [*read_timeout]]]
    [Gets the read timeout of the stream buffer. 

     Sets the read timeout of the stream buffer. ]
  ]
  
  [
    [[link urdl.reference.core.istreambuf.set_option [*set_option]]]
    [Sets an option to control the behaviour of the stream buffer. ]
  ]
  
  [
    [[link urdl.reference.core.istreambuf.set_options [*set_options]]]
    [Sets options to control the behaviour of the stream buffer. ]
  ]
  
  [
    [[link urdl.reference.core.istreambuf._istreambuf [*~istreambuf]]]
    [Destroys an object of class istreambuf. ]
  ]
  
]

['[*Protected Member Functions]]
[table
  [[Name][Description]]

  [
    [[link urdl.reference.core.istreambuf.error [*error]]]
    [Gets the last error associated with the stream. ]
  ]
  
  [
    [[link urdl.reference.core.istreambuf.underflow [*underflow]]]
    [Overrides std::streambuf behaviour. ]
  ]
  
]


['[*Requirements]]
  
[*Header:] `<urdl/istreambuf.hpp>`

[*Namespace:] `urdl`



[section:close istreambuf::close]

[indexterm2 close..istreambuf] 
Closes the stream buffer. 


  istreambuf * close();



['[*Return Value]]
      
`this` on success, a null pointer otherwise.

['[*Remarks]]
  
If `is_open() == false`, returns a null pointer. Otherwise, closes the underlying transport's resources as required. If any of those operations fail, `close` fails by returning a null pointer. 



[endsect]



[section:content_length istreambuf::content_length]

[indexterm2 content_length..istreambuf] 
Gets the length of the content obtained from the URL. 


  std::size_t content_length() const;



['[*Return Value]]
      
The length, in bytes, of the content. If the content associated with the URL does not specify a length, `std::numeric_limits<std::size_t>::max()`. 



[endsect]



[section:content_type istreambuf::content_type]

[indexterm2 content_type..istreambuf] 
Gets the MIME type of the content obtained from the URL. 


  std::string content_type() const;



['[*Return Value]]
      
A string specifying the MIME type. Examples of possible return values include `text/plain`, `text/html` and `image/png`.

['[*Remarks]]
  
Not all URL protocols support a content type. For these protocols, this function returns an empty string. 



[endsect]



[section:error istreambuf::error]

[indexterm2 error..istreambuf] 
Gets the last error associated with the stream. 


  const boost::system::error_code & error() const;



['[*Return Value]]
      
An `error_code` corresponding to the last error from the stream.

['[*Remarks]]
  
Returns a reference to an `error_code` object representing the last failure reported by an `istreambuf` function. The set of possible `error_code` values and categories depends on the protocol of the URL used to open the stream buffer. 



[endsect]



[section:get_option istreambuf::get_option]

[indexterm2 get_option..istreambuf] 
Gets the current value of an option that controls the behaviour of the stream buffer. 


  template<
      typename Option>
  Option get_option() const;



['[*Return Value]]
      
The current value of the option.

['[*Remarks]]
  
Options are uniquely identified by type. 



[endsect]



[section:get_options istreambuf::get_options]

[indexterm2 get_options..istreambuf] 
Gets the values of all options set on the stream. 


  option_set get_options() const;



['[*Return Value]]
      
An option set containing all options from the stream buffer. 



[endsect]



[section:headers istreambuf::headers]

[indexterm2 headers..istreambuf] 
Gets the protocol-specific headers obtained from the URL. 


  std::string headers() const;



['[*Return Value]]
      
A string containing the headers returned with the content from the URL. The format and interpretation of these headers is specific to the protocol associated with the URL. 



[endsect]



[section:is_open istreambuf::is_open]

[indexterm2 is_open..istreambuf] 
Determines whether the stream buffer is open. 


  bool is_open() const;



['[*Return Value]]
      
`true` if the stream buffer is open, `false` otherwise.

['[*Remarks]]
  
Returns `true` if a previous call to `open` succeeded (returned a non-null value) and there has been no intervening call to `close`. 



[endsect]



[section:istreambuf istreambuf::istreambuf]

[indexterm2 istreambuf..istreambuf] 
Constructs an object of class `istreambuf`. 


  istreambuf();



[endsect]



[section:open istreambuf::open]

[indexterm2 open..istreambuf] 
Opens the specified URL. 


  istreambuf * open(
      const url & u);



['[*Parameters]]
    

[variablelist
  
[[u][The URL to open.]]

]

['[*Return Value]]
      
`this` on success, a null pointer otherwise.

['[*Remarks]]
  
If `is_open() != false`, returns a null pointer. Otherwise, initializes the `istreambuf` as required. 



[endsect]



[section:puberror istreambuf::puberror]

[indexterm2 puberror..istreambuf] 
Gets the last error associated with the stream buffer. 


  const boost::system::error_code & puberror() const;



['[*Return Value]]
      
An `error_code` corresponding to the last error from the stream buffer.

['[*Remarks]]
  
Returns `error()`. 



[endsect]


[section:read_timeout istreambuf::read_timeout]

[indexterm2 read_timeout..istreambuf] 
Gets the read timeout of the stream buffer. 


  std::size_t ``[link urdl.reference.core.istreambuf.read_timeout.overload1 read_timeout]``() const;
  ``  [''''&raquo;''' [link urdl.reference.core.istreambuf.read_timeout.overload1 more...]]``


Sets the read timeout of the stream buffer. 


  void ``[link urdl.reference.core.istreambuf.read_timeout.overload2 read_timeout]``(
      std::size_t milliseconds);
  ``  [''''&raquo;''' [link urdl.reference.core.istreambuf.read_timeout.overload2 more...]]``


[section:overload1 istreambuf::read_timeout (1 of 2 overloads)]


Gets the read timeout of the stream buffer. 


  std::size_t read_timeout() const;



['[*Return Value]]
      
The timeout, in milliseconds, used for individual read operations on the underlying transport. 



[endsect]



[section:overload2 istreambuf::read_timeout (2 of 2 overloads)]


Sets the read timeout of the stream buffer. 


  void read_timeout(
      std::size_t milliseconds);



['[*Parameters]]
    

[variablelist
  
[[milliseconds][The timeout, in milliseconds, to be used for individual read operations on the underlying transport. ]]

]



[endsect]


[endsect]


[section:set_option istreambuf::set_option]

[indexterm2 set_option..istreambuf] 
Sets an option to control the behaviour of the stream buffer. 


  template<
      typename Option>
  void set_option(
      const Option & option);



['[*Parameters]]
    

[variablelist
  
[[option][The option to be set on the stream buffer.]]

]

['[*Remarks]]
  
Options are uniquely identified by type. 



[endsect]



[section:set_options istreambuf::set_options]

[indexterm2 set_options..istreambuf] 
Sets options to control the behaviour of the stream buffer. 


  void set_options(
      const option_set & options);



['[*Parameters]]
    

[variablelist
  
[[options][The options to be set on the stream buffer. ]]

]



[endsect]



[section:underflow istreambuf::underflow]

[indexterm2 underflow..istreambuf] 
Overrides `std::streambuf` behaviour. 


  int_type underflow();


par Remarks Behaves according to the specification of `std::streambuf::underflow()`. 


[endsect]



[section:_istreambuf istreambuf::~istreambuf]

[indexterm2 ~istreambuf..istreambuf] 
Destroys an object of class `istreambuf`. 


  ~istreambuf();



[endsect]



[endsect]

[section:option_set option_set]



  class option_set


['[*Member Functions]]
[table
  [[Name][Description]]

  [
    [[link urdl.reference.core.option_set.clear_option [*clear_option]]]
    []
  ]
  
  [
    [[link urdl.reference.core.option_set.get_option [*get_option]]]
    []
  ]
  
  [
    [[link urdl.reference.core.option_set.operator_eq_ [*operator=]]]
    []
  ]
  
  [
    [[link urdl.reference.core.option_set.option_set [*option_set]]]
    []
  ]
  
  [
    [[link urdl.reference.core.option_set.set_option [*set_option]]]
    []
  ]
  
  [
    [[link urdl.reference.core.option_set.set_options [*set_options]]]
    []
  ]
  
]


[section:clear_option option_set::clear_option]

[indexterm2 clear_option..option_set] 

  template<
      typename Option>
  void clear_option();



[endsect]



[section:get_option option_set::get_option]

[indexterm2 get_option..option_set] 

  template<
      typename Option>
  Option get_option() const;



[endsect]



[section:operator_eq_ option_set::operator=]

[indexterm2 operator=..option_set] 

  option_set & operator=(
      const option_set & other);



[endsect]


[section:option_set option_set::option_set]

[indexterm2 option_set..option_set] 

  ``[link urdl.reference.core.option_set.option_set.overload1 option_set]``();
  ``  [''''&raquo;''' [link urdl.reference.core.option_set.option_set.overload1 more...]]``

  ``[link urdl.reference.core.option_set.option_set.overload2 option_set]``(
      const option_set & other);
  ``  [''''&raquo;''' [link urdl.reference.core.option_set.option_set.overload2 more...]]``


[section:overload1 option_set::option_set (1 of 2 overloads)]



  option_set();



[endsect]



[section:overload2 option_set::option_set (2 of 2 overloads)]



  option_set(
      const option_set & other);



[endsect]


[endsect]


[section:set_option option_set::set_option]

[indexterm2 set_option..option_set] 

  template<
      typename Option>
  void set_option(
      const Option & o);



[endsect]



[section:set_options option_set::set_options]

[indexterm2 set_options..option_set] 

  void set_options(
      const option_set & other);



[endsect]



[endsect]

[section:read_stream read_stream]


The class `read_stream` supports reading content from a specified URL using synchronous or asynchronous operations. 


  class read_stream


['[*Member Functions]]
[table
  [[Name][Description]]

  [
    [[link urdl.reference.core.read_stream.async_open [*async_open]]]
    [Asynchronously opens the specified URL. ]
  ]
  
  [
    [[link urdl.reference.core.read_stream.async_read_some [*async_read_some]]]
    [Asynchronously reads some data from the stream. ]
  ]
  
  [
    [[link urdl.reference.core.read_stream.close [*close]]]
    [Closes the stream. ]
  ]
  
  [
    [[link urdl.reference.core.read_stream.content_length [*content_length]]]
    [Gets the length of the content obtained from the URL. ]
  ]
  
  [
    [[link urdl.reference.core.read_stream.content_type [*content_type]]]
    [Gets the MIME type of the content obtained from the URL. ]
  ]
  
  [
    [[link urdl.reference.core.read_stream.get_io_service [*get_io_service]]]
    [Gets the io_service associated with the stream. ]
  ]
  
  [
    [[link urdl.reference.core.read_stream.get_option [*get_option]]]
    [Gets the current value of an option that controls the behaviour of the stream. ]
  ]
  
  [
    [[link urdl.reference.core.read_stream.get_options [*get_options]]]
    [Gets the values of all options set on the stream. ]
  ]
  
  [
    [[link urdl.reference.core.read_stream.headers [*headers]]]
    [Gets the protocol-specific headers obtained from the URL. ]
  ]
  
  [
    [[link urdl.reference.core.read_stream.is_open [*is_open]]]
    [Determines whether the stream is open. ]
  ]
  
  [
    [[link urdl.reference.core.read_stream.open [*open]]]
    [Opens the specified URL. ]
  ]
  
  [
    [[link urdl.reference.core.read_stream.read_some [*read_some]]]
    [Reads some data from the stream. ]
  ]
  
  [
    [[link urdl.reference.core.read_stream.read_stream [*read_stream]]]
    [Constructs an object of class read_stream. ]
  ]
  
  [
    [[link urdl.reference.core.read_stream.set_option [*set_option]]]
    [Sets an option to control the behaviour of the stream. ]
  ]
  
  [
    [[link urdl.reference.core.read_stream.set_options [*set_options]]]
    [Sets options to control the behaviour of the stream. ]
  ]
  
]


['[*Remarks]]
  
Currently supported URL protocols are `http`, `https` and `file`.

The class `read_stream` meets the type requirements for `SyncReadStream` and `AsyncReadStream`, as defined in the Boost.Asio documentation. This allows objects of class `read_stream` to be used with the functions `boost::asio::read`, `boost::asio::async_read`, `boost::asio::read_until` and `boost::asio::async_read_until`.


['[*Example]]
  
To synchronously open the URL, read the content and write it to standard output: 

   try
   {
     boost::asio::io_service io_service;
     urdl::read_stream read_stream(io_service);
     read_stream.open("http://www.boost.org/LICENSE_1_0.txt");
     for (;;)
     {
       char data[1024];
       boost::system::error_code ec;
       std::size_t length = stream.read_some(boost::asio::buffer(data), ec);
       if (ec == boost::asio::error::eof)
         break;
       if (ec)
         throw boost::system::system_error(ec);
       os.write(data, length);
     }
   }
   catch (std::exception& e)
   {
     std::cerr << "Exception: " << e.what() << std::endl;
   }




To asynchronously open the URL, read the content and write it to standard output: 

   boost::asio::io_service io_service;
   urdl::read_stream read_stream(io_service)
   char data[1024];
   ...
   read_stream.async_open("http://www.boost.org/LICENSE_1_0.txt", open_handler);
   ...
   void open_handler(const boost::system::error_code& ec)
   {
     if (!ec)
     {
       read_stream.async_read(boost::asio::buffer(data), read_handler);
     }
   }
   ...
   void read_handler(const boost::system::error_code& ec, std::size_t length)
   {
     if (!ec)
     {
       std::cout.write(data, length);
       read_stream.async_read(boost::asio::buffer(data), read_handler);
     }
   }





['[*Requirements]]
  
[*Header:] `<urdl/read_stream.hpp>`

[*Namespace:] `urdl`



[section:async_open read_stream::async_open]

[indexterm2 async_open..read_stream] 
Asynchronously opens the specified URL. 


  template<
      typename Handler>
  void async_open(
      const url & u,
      Handler handler);



['[*Parameters]]
    

[variablelist
  
[[u][The URL to open.]]

[[handler][The handler to be called when the open operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& ec // Result of operation.
   );
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_service::post()`.]]

]

['[*Example]]
  


   void open_handler(const boost::system::error_code& ec)
   {
     if (!ec)
     {
       // Open succeeded.
     }
   }
   ...
   urdl::read_stream read_stream(io_service);
   read_stream.async_open("http://www.boost.org/", open_handler);






[endsect]



[section:async_read_some read_stream::async_read_some]

[indexterm2 async_read_some..read_stream] 
Asynchronously reads some data from the stream. 


  template<
      typename MutableBufferSequence,
      typename Handler>
  void async_read_some(
      const MutableBufferSequence & buffers,
      Handler handler);



['[*Parameters]]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be read. The type must meet the requirements for `MutableBufferSequence`, as defined in the Boost.Asio documentation. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& ec, // Result of operation.
     std::size_t bytes_transferred        // Number of bytes read.
   );
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_service::post()`.]]

]

['[*Remarks]]
  
The asynchronous operation will continue until one or more bytes of data has been read successfully, or until an error occurs.

The `async_read_some` operation may not read all of the requested number of bytes. Consider using the `boost::asio::async_read` function if you need to ensure that the requested amount of data is read before the asynchronous operation completes.


['[*Example]]
  
To read into a single data buffer use the `boost::asio::buffer` function as follows: 

   read_stream.async_read_some(boost::asio::buffer(data, size), handler);


See the documentation for the `boost::asio::buffer` function for information on reading into multiple buffers in one go, and how to use it with arrays, `boost::array` or `std::vector`. 



[endsect]


[section:close read_stream::close]

[indexterm2 close..read_stream] 
Closes the stream. 


  void ``[link urdl.reference.core.read_stream.close.overload1 close]``();
  ``  [''''&raquo;''' [link urdl.reference.core.read_stream.close.overload1 more...]]``

  boost::system::error_code ``[link urdl.reference.core.read_stream.close.overload2 close]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link urdl.reference.core.read_stream.close.overload2 more...]]``


[section:overload1 read_stream::close (1 of 2 overloads)]


Closes the stream. 


  void close();



['[*Exceptions]]
    

[variablelist
  
[[asio::system_error][Thrown on failure.]]

]

['[*Remarks]]
  
Any asynchronous open or read operations will be cancelled, and will complete with the `boost::asio::error::operation_aborted` error. 



[endsect]



[section:overload2 read_stream::close (2 of 2 overloads)]


Closes the stream. 


  boost::system::error_code close(
      boost::system::error_code & ec);



['[*Parameters]]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]

['[*Return Value]]
      
`ec`.

['[*Remarks]]
  
Any asynchronous open or read operations will be cancelled, and will complete with the `boost::asio::error::operation_aborted` error. 



[endsect]


[endsect]


[section:content_length read_stream::content_length]

[indexterm2 content_length..read_stream] 
Gets the length of the content obtained from the URL. 


  std::size_t content_length() const;



['[*Return Value]]
      
The length, in bytes, of the content. If the content associated with the URL does not specify a length, `std::numeric_limits<std::size_t>::max()`. 



[endsect]



[section:content_type read_stream::content_type]

[indexterm2 content_type..read_stream] 
Gets the MIME type of the content obtained from the URL. 


  std::string content_type() const;



['[*Return Value]]
      
A string specifying the MIME type. Examples of possible return values include `text/plain`, `text/html` and `image/png`.

['[*Remarks]]
  
Not all URL protocols support a content type. For these protocols, this function returns an empty string. 



[endsect]



[section:get_io_service read_stream::get_io_service]

[indexterm2 get_io_service..read_stream] 
Gets the `io_service` associated with the stream. 


  boost::asio::io_service & get_io_service();



['[*Return Value]]
      
A reference to the `io_service` object that the stream will use to dispatch handlers. Ownership is not transferred to the caller. 



[endsect]



[section:get_option read_stream::get_option]

[indexterm2 get_option..read_stream] 
Gets the current value of an option that controls the behaviour of the stream. 


  template<
      typename Option>
  Option get_option() const;



['[*Return Value]]
      
The current value of the option.

['[*Remarks]]
  
Options are uniquely identified by type.

['[*Example]]
  


   urdl::read_stream stream(io_service);
   urdl::http::max_redirects option
     = stream.get_option<urdl::http::max_redirects>();
   std::size_t value = option.value();






[endsect]



[section:get_options read_stream::get_options]

[indexterm2 get_options..read_stream] 
Gets the values of all options set on the stream. 


  option_set get_options() const;



['[*Return Value]]
      
An option set containing all options from the stream.

['[*Example]]
  


   urdl::read_stream stream(io_service);
   ...
   urdl::option_set options(stream.get_options());
   urdl::http::max_redirects option
     = options.get_option<urdl::http::max_redirects>();
   std::size_t value = option.value();






[endsect]



[section:headers read_stream::headers]

[indexterm2 headers..read_stream] 
Gets the protocol-specific headers obtained from the URL. 


  std::string headers() const;



['[*Return Value]]
      
A string containing the headers returned with the content from the URL. The format and interpretation of these headers is specific to the protocol associated with the URL. 



[endsect]



[section:is_open read_stream::is_open]

[indexterm2 is_open..read_stream] 
Determines whether the stream is open. 


  bool is_open() const;



['[*Return Value]]
      
`true` if the stream is open, `false` otherwise. 



[endsect]


[section:open read_stream::open]

[indexterm2 open..read_stream] 
Opens the specified URL. 


  void ``[link urdl.reference.core.read_stream.open.overload1 open]``(
      const url & u);
  ``  [''''&raquo;''' [link urdl.reference.core.read_stream.open.overload1 more...]]``

  boost::system::error_code ``[link urdl.reference.core.read_stream.open.overload2 open]``(
      const url & u,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link urdl.reference.core.read_stream.open.overload2 more...]]``


[section:overload1 read_stream::open (1 of 2 overloads)]


Opens the specified URL. 


  void open(
      const url & u);



['[*Parameters]]
    

[variablelist
  
[[u][The URL to open.]]

]

['[*Exceptions]]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]

['[*Example]]
  


   urdl::read_stream read_stream(io_service);

   try
   {
     read_stream.open("http://www.boost.org");
   }
   catch (boost::system::error_code& e)
   {
     std::cerr << e.what() << std::endl;
   }






[endsect]



[section:overload2 read_stream::open (2 of 2 overloads)]


Opens the specified URL. 


  boost::system::error_code open(
      const url & u,
      boost::system::error_code & ec);



['[*Parameters]]
    

[variablelist
  
[[u][The URL to open.]]

[[ec][Set to indicate what error occurred, if any.]]

]

['[*Return Value]]
      
`ec`.

['[*Example]]
  


   urdl::read_stream read_stream(io_service);

   boost::system::error_code ec;
   read_stream.open("http://www.boost.org", ec);
   if (ec)
   {
     std::cerr << ec.message() << std::endl;
   }






[endsect]


[endsect]

[section:read_some read_stream::read_some]

[indexterm2 read_some..read_stream] 
Reads some data from the stream. 


  template<
      typename MutableBufferSequence>
  std::size_t ``[link urdl.reference.core.read_stream.read_some.overload1 read_some]``(
      const MutableBufferSequence & buffers);
  ``  [''''&raquo;''' [link urdl.reference.core.read_stream.read_some.overload1 more...]]``

  template<
      typename MutableBufferSequence>
  std::size_t ``[link urdl.reference.core.read_stream.read_some.overload2 read_some]``(
      const MutableBufferSequence & buffers,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link urdl.reference.core.read_stream.read_some.overload2 more...]]``


[section:overload1 read_stream::read_some (1 of 2 overloads)]


Reads some data from the stream. 


  template<
      typename MutableBufferSequence>
  std::size_t read_some(
      const MutableBufferSequence & buffers);



['[*Parameters]]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be read. The type must meet the requirements for `MutableBufferSequence`, as defined in the Boost.Asio documentation.]]

]

['[*Return Value]]
      
The number of bytes read.

['[*Exceptions]]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. An error code of `boost::asio::error::eof` indicates that the end of the URL content has been reached.]]

]

['[*Remarks]]
  
The function call will block until one or more bytes of data has been read successfully, or until an error occurs.

The `read_some` operation may not read all of the requested number of bytes. Consider using the `boost::asio::read` function if you need to ensure that the requested amount of data is read before the blocking operation completes.


['[*Example]]
  
To read into a single data buffer use the `boost::asio::buffer` function as follows: 

   read_stream.read_some(boost::asio::buffer(data, size));


See the documentation for the `boost::asio::buffer` function for information on reading into multiple buffers in one go, and how to use it with arrays, `boost::array` or `std::vector`. 



[endsect]



[section:overload2 read_stream::read_some (2 of 2 overloads)]


Reads some data from the stream. 


  template<
      typename MutableBufferSequence>
  std::size_t read_some(
      const MutableBufferSequence & buffers,
      boost::system::error_code & ec);



['[*Parameters]]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be read. The type must meet the requirements for `MutableBufferSequence`, as defined in the Boost.Asio documentation.]]

[[ec][Set to indicate what error occurred, if any. An error code of `boost::asio::error::eof` indicates that the end of the URL content has been reached.]]

]

['[*Return Value]]
      
The number of bytes read.

['[*Remarks]]
  
This function is used to read data from the stream. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.

The `read_some` operation may not read all of the requested number of bytes. Consider using the `boost::asio::read` function if you need to ensure that the requested amount of data is read before the blocking operation completes.


['[*Example]]
  
To read into a single data buffer use the `boost::asio::buffer` function as follows: 

   read_stream.read_some(boost::asio::buffer(data, size));


See the documentation for the `boost::asio::buffer` function for information on reading into multiple buffers in one go, and how to use it with arrays, `boost::array` or `std::vector`. 



[endsect]


[endsect]


[section:read_stream read_stream::read_stream]

[indexterm2 read_stream..read_stream] 
Constructs an object of class `read_stream`. 


  explicit read_stream(
      boost::asio::io_service & io_service);



['[*Parameters]]
    

[variablelist
  
[[io_service][The `io_service` object that the stream will use to dispatch handlers for any asynchronous operations performed on the stream. ]]

]



[endsect]



[section:set_option read_stream::set_option]

[indexterm2 set_option..read_stream] 
Sets an option to control the behaviour of the stream. 


  template<
      typename Option>
  void set_option(
      const Option & option);



['[*Parameters]]
    

[variablelist
  
[[option][The option to be set on the stream.]]

]

['[*Remarks]]
  
Options are uniquely identified by type.

['[*Example]]
  


   urdl::read_stream stream(io_service);
   stream.set_option(urdl::http::max_redirects(1));






[endsect]



[section:set_options read_stream::set_options]

[indexterm2 set_options..read_stream] 
Sets options to control the behaviour of the stream. 


  void set_options(
      const option_set & options);



['[*Parameters]]
    

[variablelist
  
[[options][The options to be set on the stream. The options in the set are added on top of any options already set on the stream.]]

]

['[*Example]]
  


   urdl::read_stream stream(io_service);
   urdl::option_set options;
   options.set_option(urdl::http::max_redirects(1));
   options.set_option(urdl::ssl::verify_peer(false));
   stream.set_options(options);






[endsect]



[endsect]

[section:url url]



  class url


['[*Types]]
[table
  [[Name][Description]]

  [

    [[link urdl.reference.core.url.parts_type [*parts_type]]]
    []
  
  ]

]

['[*Member Functions]]
[table
  [[Name][Description]]

  [
    [[link urdl.reference.core.url.fragment [*fragment]]]
    []
  ]
  
  [
    [[link urdl.reference.core.url.from_string [*from_string]]]
    []
  ]
  
  [
    [[link urdl.reference.core.url.host [*host]]]
    []
  ]
  
  [
    [[link urdl.reference.core.url.path [*path]]]
    []
  ]
  
  [
    [[link urdl.reference.core.url.port [*port]]]
    []
  ]
  
  [
    [[link urdl.reference.core.url.protocol [*protocol]]]
    []
  ]
  
  [
    [[link urdl.reference.core.url.query [*query]]]
    []
  ]
  
  [
    [[link urdl.reference.core.url.to_string [*to_string]]]
    []
  ]
  
  [
    [[link urdl.reference.core.url.url [*url]]]
    []
  ]
  
  [
    [[link urdl.reference.core.url.user_info [*user_info]]]
    []
  ]
  
]

['[*Friends]]
[table
  [[Name][Description]]

  [
    [[link urdl.reference.core.url.operator_not__eq_ [*operator!=]]]
    []
  ]
  
  [
    [[link urdl.reference.core.url.operator_lt_ [*operator<]]]
    []
  ]
  
  [
    [[link urdl.reference.core.url.operator_eq__eq_ [*operator==]]]
    []
  ]
  
]


[section:fragment url::fragment]

[indexterm2 fragment..url] 

  std::string fragment() const;



[endsect]


[section:from_string url::from_string]

[indexterm2 from_string..url] 

  static url ``[link urdl.reference.core.url.from_string.overload1 from_string]``(
      const char * s);
  ``  [''''&raquo;''' [link urdl.reference.core.url.from_string.overload1 more...]]``

  static url ``[link urdl.reference.core.url.from_string.overload2 from_string]``(
      const char * s,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link urdl.reference.core.url.from_string.overload2 more...]]``

  static url ``[link urdl.reference.core.url.from_string.overload3 from_string]``(
      const std::string & s);
  ``  [''''&raquo;''' [link urdl.reference.core.url.from_string.overload3 more...]]``

  static url ``[link urdl.reference.core.url.from_string.overload4 from_string]``(
      const std::string & s,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link urdl.reference.core.url.from_string.overload4 more...]]``


[section:overload1 url::from_string (1 of 4 overloads)]



  static url from_string(
      const char * s);



[endsect]



[section:overload2 url::from_string (2 of 4 overloads)]



  static url from_string(
      const char * s,
      boost::system::error_code & ec);



[endsect]



[section:overload3 url::from_string (3 of 4 overloads)]



  static url from_string(
      const std::string & s);



[endsect]



[section:overload4 url::from_string (4 of 4 overloads)]



  static url from_string(
      const std::string & s,
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:host url::host]

[indexterm2 host..url] 

  std::string host() const;



[endsect]



[section:operator_not__eq_ url::operator!=]

[indexterm2 operator!=..url] 

  friend bool operator!=(
      const url & a,
      const url & b);



[endsect]



[section:operator_lt_ url::operator<]

[indexterm2 operator<..url] 

  friend bool operator<(
      const url & a,
      const url & b);



[endsect]



[section:operator_eq__eq_ url::operator==]

[indexterm2 operator==..url] 

  friend bool operator==(
      const url & a,
      const url & b);



[endsect]



[section:parts_type url::parts_type]

[indexterm2 parts_type..url] 

  enum parts_type

['[*Values]]
[variablelist

  [
    [protocol_part]
    []
  ]

  [
    [user_info_part]
    []
  ]

  [
    [host_part]
    []
  ]

  [
    [port_part]
    []
  ]

  [
    [path_part]
    []
  ]

  [
    [query_part]
    []
  ]

  [
    [fragment_part]
    []
  ]

  [
    [all_parts]
    []
  ]

]



[endsect]



[section:path url::path]

[indexterm2 path..url] 

  std::string path() const;



[endsect]



[section:port url::port]

[indexterm2 port..url] 

  unsigned short port() const;



[endsect]



[section:protocol url::protocol]

[indexterm2 protocol..url] 

  std::string protocol() const;



[endsect]



[section:query url::query]

[indexterm2 query..url] 

  std::string query() const;



[endsect]



[section:to_string url::to_string]

[indexterm2 to_string..url] 

  std::string to_string(
      int parts = all_parts) const;



[endsect]


[section:url url::url]

[indexterm2 url..url] 

  ``[link urdl.reference.core.url.url.overload1 url]``();
  ``  [''''&raquo;''' [link urdl.reference.core.url.url.overload1 more...]]``

  ``[link urdl.reference.core.url.url.overload2 url]``(
      const char * s);
  ``  [''''&raquo;''' [link urdl.reference.core.url.url.overload2 more...]]``

  ``[link urdl.reference.core.url.url.overload3 url]``(
      const std::string & s);
  ``  [''''&raquo;''' [link urdl.reference.core.url.url.overload3 more...]]``


[section:overload1 url::url (1 of 3 overloads)]



  url();



[endsect]



[section:overload2 url::url (2 of 3 overloads)]



  url(
      const char * s);



[endsect]



[section:overload3 url::url (3 of 3 overloads)]



  url(
      const std::string & s);



[endsect]


[endsect]


[section:user_info url::user_info]

[indexterm2 user_info..url] 

  std::string user_info() const;



[endsect]



[endsect]


[endsect]

[section:opt Options]

  
[section:http__max_redirects http::max_redirects]


Option to specify the maximum number of allowed HTTP redirects. 


  class max_redirects


['[*Member Functions]]
[table
  [[Name][Description]]

  [
    [[link urdl.reference.opt.http__max_redirects.max_redirects [*max_redirects]]]
    [Constructs an object of class max_redirects. ]
  ]
  
  [
    [[link urdl.reference.opt.http__max_redirects.value [*value]]]
    [Gets the value of the option. 

     Sets the value of the option. ]
  ]
  
]


['[*Remarks]]
  
The default value is for there to be no limit on the number of allowed redirects. Set the option to 0 to disable HTTP redirects.

['[*Example]]
  
To set maximum number of redirects for an object of class `urdl::istream:`

   urdl::istream is;
   is.set_option(urdl::http::max_redirects(1));
   is.open("http://www.boost.org");




To set maximum number of redirects for an object of class `urdl::read_stream:`

   urdl::read_stream stream;
   stream.set_option(urdl::http::max_redirects(1));
   stream.open("http://www.boost.org");





['[*Requirements]]
  
[*Header:] `<urdl/http.hpp>`

[*Namespace:] `urdl::http`


[section:max_redirects http::max_redirects::max_redirects]

[indexterm2 max_redirects..http::max_redirects] 
Constructs an object of class `max_redirects`. 


  ``[link urdl.reference.opt.http__max_redirects.max_redirects.overload1 max_redirects]``();
  ``  [''''&raquo;''' [link urdl.reference.opt.http__max_redirects.max_redirects.overload1 more...]]``

  explicit ``[link urdl.reference.opt.http__max_redirects.max_redirects.overload2 max_redirects]``(
      std::size_t v);
  ``  [''''&raquo;''' [link urdl.reference.opt.http__max_redirects.max_redirects.overload2 more...]]``


[section:overload1 http::max_redirects::max_redirects (1 of 2 overloads)]


Constructs an object of class `max_redirects`. 


  max_redirects();



['[*Remarks]]
  
Postcondition: `value() == std::numeric_limits<std::size_t>::max()`. 



[endsect]



[section:overload2 http::max_redirects::max_redirects (2 of 2 overloads)]


Constructs an object of class `max_redirects`. 


  explicit max_redirects(
      std::size_t v);



['[*Parameters]]
    

[variablelist
  
[[v][The desired value for the option.]]

]

['[*Remarks]]
  
Postcondition: `value() == v`



[endsect]


[endsect]

[section:value http::max_redirects::value]

[indexterm2 value..http::max_redirects] 
Gets the value of the option. 


  std::size_t ``[link urdl.reference.opt.http__max_redirects.value.overload1 value]``() const;
  ``  [''''&raquo;''' [link urdl.reference.opt.http__max_redirects.value.overload1 more...]]``


Sets the value of the option. 


  void ``[link urdl.reference.opt.http__max_redirects.value.overload2 value]``(
      std::size_t v);
  ``  [''''&raquo;''' [link urdl.reference.opt.http__max_redirects.value.overload2 more...]]``


[section:overload1 http::max_redirects::value (1 of 2 overloads)]


Gets the value of the option. 


  std::size_t value() const;



['[*Return Value]]
      
The value of the option. 



[endsect]



[section:overload2 http::max_redirects::value (2 of 2 overloads)]


Sets the value of the option. 


  void value(
      std::size_t v);



['[*Parameters]]
    

[variablelist
  
[[v][The desired value for the option.]]

]

['[*Remarks]]
  
Postcondition: `value() == v`



[endsect]


[endsect]


[endsect]


[endsect]

[section:err Error Handling]

  

[section:http__errc__errc_t http::errc::errc_t]

[indexterm1 http::errc::errc_t] 
HTTP error codes. 


  enum errc_t

['[*Values]]
[variablelist

  [
    [malformed_status_line]
    [The response's status line was malformed. ]
  ]

  [
    [malformed_response_headers]
    [The response's headers were malformed. ]
  ]

  [
    [continue_request]
    [The server-generated status code "100 Continue". ]
  ]

  [
    [switching_protocols]
    [The server-generated status code "101 Switching Protocols". ]
  ]

  [
    [ok]
    [The server-generated status code "200 OK". ]
  ]

  [
    [created]
    [The server-generated status code "201 Created". ]
  ]

  [
    [accepted]
    [The server-generated status code "202 Accepted". ]
  ]

  [
    [non_authoritative_information]
    [The server-generated status code "203 Non-Authoritative Information". ]
  ]

  [
    [no_content]
    [The server-generated status code "204 No Content". ]
  ]

  [
    [reset_content]
    [The server-generated status code "205 Reset Content". ]
  ]

  [
    [partial_content]
    [The server-generated status code "206 Partial Content". ]
  ]

  [
    [multiple_choices]
    [The server-generated status code "300 Multiple Choices". ]
  ]

  [
    [moved_permanently]
    [The server-generated status code "301 Moved Permanently". ]
  ]

  [
    [found]
    [The server-generated status code "302 Found". ]
  ]

  [
    [see_other]
    [The server-generated status code "303 See Other". ]
  ]

  [
    [not_modified]
    [The server-generated status code "304 Not Modified". ]
  ]

  [
    [use_proxy]
    [The server-generated status code "305 Use Proxy". ]
  ]

  [
    [temporary_redirect]
    [The server-generated status code "307 Temporary Redirect". ]
  ]

  [
    [bad_request]
    [The server-generated status code "400 Bad Request". ]
  ]

  [
    [unauthorized]
    [The server-generated status code "401 Unauthorized". ]
  ]

  [
    [payment_required]
    [The server-generated status code "402 Payment Required". ]
  ]

  [
    [forbidden]
    [The server-generated status code "403 Forbidden". ]
  ]

  [
    [not_found]
    [The server-generated status code "404 Not Found". ]
  ]

  [
    [method_not_allowed]
    [The server-generated status code "405 Method Not Allowed". ]
  ]

  [
    [not_acceptable]
    [The server-generated status code "406 Not Acceptable". ]
  ]

  [
    [proxy_authentication_required]
    [The server-generated status code "407 Proxy Authentication Required". ]
  ]

  [
    [request_timeout]
    [The server-generated status code "408 Request Time-out". ]
  ]

  [
    [conflict]
    [The server-generated status code "409 Conflict". ]
  ]

  [
    [gone]
    [The server-generated status code "410 Gone". ]
  ]

  [
    [length_required]
    [The server-generated status code "411 Length Required". ]
  ]

  [
    [precondition_failed]
    [The server-generated status code "412 Precondition Failed". ]
  ]

  [
    [request_entity_too_large]
    [The server-generated status code "413 Request Entity Too Large". ]
  ]

  [
    [request_uri_too_large]
    [The server-generated status code "414 Request URI Too Large". ]
  ]

  [
    [unsupported_media_type]
    [The server-generated status code "415 Unsupported Media Type". ]
  ]

  [
    [requested_range_not_satisfiable]
    [The server-generated status code "416 Requested Range Not Satisfiable". ]
  ]

  [
    [expectation_failed]
    [The server-generated status code "417 Expectation Failed". ]
  ]

  [
    [internal_server_error]
    [The server-generated status code "500 Internal Server Error". ]
  ]

  [
    [not_implemented]
    [The server-generated status code "501 Not Implemented". ]
  ]

  [
    [bad_gateway]
    [The server-generated status code "502 Bad Gateway". ]
  ]

  [
    [service_unavailable]
    [The server-generated status code "503 Service Unavailable". ]
  ]

  [
    [gateway_timeout]
    [The server-generated status code "504 Gateway Timeout". ]
  ]

  [
    [version_not_supported]
    [The server-generated status code "505 HTTP Version Not Supported". ]
  ]

]


The enumerators of type `errc_t` are implicitly convertible to objects of type `boost::system::error_code`.


['[*Requirements]]
  
[*Header:] `<urdl/http.hpp>`

[*Namespace:] `urdl::http`



[endsect]



[section:http__errc__make_error_code http::errc::make_error_code]

[indexterm1 http::errc::make_error_code] 
Converts a value of type `errc_t` to a corresponding object of type `boost::system::error_code`. 


  boost::system::error_code make_error_code(
      errc_t e);



['[*Requirements]]
  
[*Header:] `<urdl/http.hpp>`

[*Namespace:] `urdl::http`



[endsect]



[section:http__error_category http::error_category]

[indexterm1 http::error_category] 
Gets the error category for HTTP errors. 


  const boost::system::error_category & error_category();



['[*Return Value]]
      
The `boost::system::error_category` used for HTTP errors.

['[*Requirements]]
  
[*Header:] `<urdl/http.hpp>`

[*Namespace:] `urdl::http`



[endsect]



[endsect]

  
[endsect]